#include "sub.h"

intain(argc, char* argv[])
{
	
 printf (" start\n");
 Windows With Rect("Block Breaker", SCREEN_WIDTH, SCREEN_HIGHT) 생성;
 //리턴 게임 1 ();
 반환 0;
}

#include "sub.h"

// 전처리

// 함수 정의

void printf2(int a)
{
	printf("%d\n", a);
}

// SDL_Renderer에 사각형을 그리는 함수

void drawRect(SDL_Renderer* renderer, int x, int y, int width, int height, SDL_Color color) {
    SDL_SetRenderDrawColor(renderer, color.r, color.g, color.b, color.a);
    SDL_Rect rect = { x - (width / 2) , y - (height / 2), width, height };
    SDL_RenderFillRect(renderer, &rect);
}

void drawBox(SDL_Renderer* renderer, SDL_Rect rect, SDL_Color color) {
    SDL_SetRenderDrawColor(renderer, color.r, color.g, color.b, color.a);
    SDL_Rect box = { rect.x - (rect.w / 2) , rect.y - (rect.h / 2), rect.w, rect.h };
    SDL_RenderFillRect(renderer, &rect);
}

// 창을 만들고 초기화 하는 함수
SDL_Window* createWindow(const char* title, int width, int height) {
    // SDL 라이브러리 초기화
    if (SDL_Init(SDL_INIT_VIDEO) != 0) {
        fprintf(stderr, "SDL 초기화 실패: %s\n", SDL_GetError());
        return NULL;
    }

    // SDL_ttf 라이브러리 초기화
    if (TTF_Init() != 0) {
        fprintf(stderr, "SDL_ttf 초기화 실패: %s\n", TTF_GetError());
        SDL_Quit();
        return NULL;
    }

    // 창 생성
    SDL_Window* window = SDL_CreateWindow(title, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, width, height, SDL_WINDOW_SHOWN | SDL_WINDOW_INPUT_FOCUS | SDL_WINDOW_MOUSE_FOCUS);
    if (window == NULL) {
        fprintf(stderr, "창 생성 실패: %s\n", SDL_GetError());
        TTF_Quit();
        SDL_Quit();
        return NULL;
    }

    return window;
}

double calculateAcceleration(double initialAcceleration, double deltaTime) {
    // 가속도 = 초기 가속도 + 시간 * 변화율
    return initialAcceleration * deltaTime;
}

void createWindowWithRect(const char* title, int width, int height) {
    // 창 생성
    SDL_Window* window = createWindow(title, width, height);
    if (!window) {
        return;
    }

    // 렌더러 생성
    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
    if (!renderer) {
        printf("렌더러를 만들 수 없습니다: %s\n", SDL_GetError());
        SDL_DestroyWindow(window);
        SDL_Quit();
        return;
    }

    // 검은색 배경으로 채우기
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderClear(renderer);

    // 사각형 초기 위치 설정 (화면 상단 중앙)
    int rectX = width / 2;
    int rectY = -height / 2; // 화면 위쪽 밖에서 시작
    int targetY = height / 2;

    // 사각형 색 그리기
    SDL_Color Color1 = { 255, 255, 255, 255 }; // R, G, B, A
    SDL_Color Color2 = { 0, 0, 0, 255 }; // R, G, B, A

    // 사각형을 화면 중앙으로 이동시키는 애니메이션
    float deltaTime = 0.125f; // 시간 간격
    float speedY = 0.0f; // 초기 속도
    float accelerationY = 0.33f; // Y축 가속도
    char reachedCenter = 8;

    for (float timer = 0; timer <= 400; timer += deltaTime) {
        // 위치 업데이트
        rectY += speedY * deltaTime * 100;

        // 화면 지우기
        SDL_SetRenderDrawColor(renderer, 24, 24, 24, 255);
        SDL_RenderClear(renderer);

        // 사각형 그리기
        drawRect(renderer, rectX, rectY, 460, 640, Color1);
        drawRect(renderer, rectX, rectY, 440, 620, Color2);

        TextS1(renderer, "Blockout", (SDL_Rect) { rectX, rectY - 120, 320, 80 });
        TextS1(renderer, "Game Start", (SDL_Rect) { rectX, rectY + 0, 320, 80 });
        TextS1(renderer, "end", (SDL_Rect) { rectX, rectY + 120, 320, 80 });

        // 화면 업데이트
        SDL_RenderPresent(renderer);

        // 화면 중앙에 도달하면 속도 반전
        if (reachedCenter && rectY >= targetY) {
            reachedCenter--;
            speedY = -speedY / 1.56; // 속도 반전 및 감속
        }
        else if (reachedCenter <= 0)
        {
            break;
        }

        // 속도 업데이트
        speedY += accelerationY * deltaTime;

        // 시간 간격만큼 대기
        SDL_Delay((Uint32)(deltaTime * 8));
    }

    

    // 2초 대기
    // SDL_Delay(2000);

    titleRenderer(window, renderer, rectX, rectY);

    // 종료 처리
    cleanup(window, renderer);
}

void titleRenderer(SDL_Window* window, SDL_Renderer* renderer, int rectX, int rectY)
{

    unsigned int boxNumber = 0;
    
    while (1)
    {

        SDL_SetRenderDrawColor(renderer, 24, 24, 24, 255);
        SDL_RenderClear(renderer);

        // 사각형 그리기
        drawRect(renderer, rectX, rectY, 460, 640, (SDL_Color){ 255, 255, 255, 255 } );
        drawRect(renderer, rectX, rectY, 440, 620, (SDL_Color){ 0, 0, 0, 255 } );

        TextS1(renderer, "Blockout", (SDL_Rect) { rectX, rectY - 120, 320, 80 } );
        if (TextS2(renderer, "Game Start", (SDL_Rect) { rectX, rectY + 0, 320, 80 }, 1, & boxNumber))
        {
            goto titleRendererBox1;
        }
        if (TextS2(renderer, "end", (SDL_Rect) { rectX, rectY + 120, 320, 80 }, 2, & boxNumber))
        {
            goto titleRendererBox2;
        }

        // 화면 업데이트
        SDL_RenderPresent(renderer);
    }
        
    titleRendererBox1:
        
    SDL_SetRenderDrawColor(renderer, 24, 24, 24, 255);
    SDL_RenderClear(renderer);
    SDL_RenderPresent(renderer);

    game1(window, renderer);
    printf("rit\n");
    titleRenderer(window, renderer, rectX, rectY);
    
    goto titleRendererEnd;
    titleRendererBox2:

    SDL_SetRenderDrawColor(renderer, 24, 24, 24, 255);
    SDL_RenderClear(renderer);
    SDL_RenderPresent(renderer);


    titleRendererEnd:
    printf("and\n");
}

void renderText(SDL_Renderer* renderer, const char* text, SDL_Color textColor, SDL_Color bgColor, SDL_Rect textBox, int textSize) {
    
    //폰트 크기 생성
    TTF_Font* resizedFont = TTF_OpenFont("arial.ttf", textSize);
    if (!resizedFont) {
        printf("Failed to load font: %s\n", TTF_GetError());
        return;
    }
    // 텍스트 표면 생성
    SDL_Surface* textSurface = TTF_RenderText_Blended(resizedFont, text, textColor);
    if (!textSurface) {
        printf("Unable to create text surface: %s\n", TTF_GetError());
        TTF_CloseFont(resizedFont);
        return;
    }

    // 텍스트 텍스처 생성
    SDL_Texture* textTexture = SDL_CreateTextureFromSurface(renderer, textSurface);
    SDL_FreeSurface(textSurface);
    if (!textTexture) {
        printf("Unable to create text texture: %s\n", SDL_GetError());
        TTF_CloseFont(resizedFont);
        return;
    }

    // 텍스트 위치 계산 (박스의 중심)
    SDL_Rect textRect;
    textRect.w = textSurface->w;
    textRect.h = textSurface->h;
    textRect.x = textBox.x + (0 - textRect.w) / 2;
    textRect.y = textBox.y + (0 - textRect.h) / 2;

    // 박스 그리기
    drawRect(renderer, textBox.x, textBox.y, textBox.w, textBox.h, bgColor);

    // 텍스트 그리기
    SDL_RenderCopy(renderer, textTexture, NULL, &textRect);
    SDL_DestroyTexture(textTexture);
    TTF_CloseFont(resizedFont);
}


    void TextS1(SDL_Renderer * renderer, const char* txet, SDL_Rect textBox)
{
    SDL_Color textColor = { 0, 0, 0, 255 };
    SDL_Color bgColor = { 255, 255, 0, 255 };


    int textSize = 20; // Text size in points
    renderText(renderer, txet, textColor, bgColor, textBox, textSize);
}

bool TextS2(SDL_Renderer * renderer, const char* txet, SDL_Rect textBox, int id, int* boxNumber)
{
    SDL_Color textColor = { 0, 0, 0, 255 };
    int textSize = 20; // Text size in points

    SDL_Color bgColor = { 255, 255, 0, 255 };
    if (id == *boxNumber)
    {
        bgColor = (SDL_Color){ 255, 0, 0, 255 };
    }

    renderText(renderer, txet, textColor, bgColor, textBox, textSize);
    return processInput(renderer, textBox, id, boxNumber);
}

void cleanup(SDL_Window* window, SDL_Renderer* renderer) {
    if (renderer) {
        SDL_DestroyRenderer(renderer);
    }
    if (window) {
        SDL_DestroyWindow(window);
    }
    TTF_Quit();
    SDL_Quit();
}

bool processInput(SDL_Renderer* renderer, SDL_Rect boxRect, int id, int* boxNumber) {

    bool is = false;

    SDL_Event event;
    while (SDL_PollEvent(&event)) {
        switch (event.type) {
        case SDL_MOUSEBUTTONDOWN:
 만약에 (사건이)단추버튼 == SDL_BUTTON_LEFT) {
 만약 (*box Number == id)
 {
 = 참입니다.
 }
 }
 부서짐;
 케이스 SDL_MUSE MOTION:
 if (event.motion.x >= boxRect.x - boxRect.w / 2 & & event.motion.x <= boxRect.x + boxRect.w / 2 & & &
 event.motion.y >= boxRect.y - boxRect.h / 2 & event.motion.y <= boxRect.y + boxRect.h / 2) {
 *box Number = id;
 }
 부서짐;

 케이스 SDL_QUIT:
 거짓으로 반환합니다.
 케이스 SDL_KEYDOWN:
 switch(event.key).keysym.sym) {
 케이스 SDLK_UP:
 스위치(*box Number)
 {
 case 0: *box 번호 = 2;
 부서짐;
 케이스 1: *box 번호 = 2;
 부서짐;
 케이스 2: *box 번호 = 1;
 부서짐;
 기본값: *box Number = 1;
 }
 부서짐;
 케이스 SDLK_DOWN:
 스위치(*box Number)
 {
 case 0: *box 번호 = 1;
 부서짐;
 케이스 1: *box 번호 = 2;
 부서짐;
 케이스 2: *box 번호 = 1;
 부서짐;
 기본값: *box Number = 2;
 }
 부서짐;
            
 케이스 SDLK_RETURN:
 케이스 SDLK_SPACE:
 만약 (*box Number == id)
 {
 = 참입니다.
 }
 부서짐;
 기본값:
 부서짐;
 }
 부서짐;
 기본값:
 부서짐;
 }
 }
 반환은;
}

#include "sub.h"

// 초기화

#define WINDOW_WIDTH 1080
#define WINDOW_HEIGHT 720
#define PADDLE_WIDTH 120
#define PADDLE_HEIGHT 10
#define BALL_SIZE 20
#define BLOCK_WIDTH 134
#define BLOCK_HEIGHT 50
#define BLOCK_ROWS 3
#define BLOCK_COLUMNS 7

typedef struct {
    SDL_Rect rect;
    SDL_Color color;
    bool alive;
} Block;

bool initSDL(SDL_Window** window, SDL_Renderer** renderer) {
    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
        printf("SDL could not initialize! SDL_Error: %s\n", SDL_GetError());
        return false;
    }

    if (TTF_Init() == -1) {
        printf("SDL_ttf could not initialize! TTF_Error: %s\n", TTF_GetError());
        return false;
    }

    *window = SDL_CreateWindow("Breakout Game", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, WINDOW_WIDTH, WINDOW_HEIGHT, SDL_WINDOW_SHOWN);
    if (!*window) {
        printf("Window could not be created! SDL_Error: %s\n", SDL_GetError());
        return false;
    }

    *renderer = SDL_CreateRenderer(*window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
    if (!*renderer) {
        printf("Renderer could not be created! SDL_Error: %s\n", SDL_GetError());
        return false;
    }

    return true;
}

void closeSDL(SDL_Window* window, SDL_Renderer* renderer) {
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    TTF_Quit();
    SDL_Quit();
}

// 그리기

void renderText2(SDL_Renderer* renderer, const char* message, TTF_Font* font, SDL_Color color, SDL_Rect rect) {
    SDL_Surface* surface = TTF_RenderText_Blended(font, message, color);
    SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, surface);
    SDL_RenderCopy(renderer, texture, NULL, &rect);
    SDL_FreeSurface(surface);
    SDL_DestroyTexture(texture);
}

void drawPaddle(SDL_Renderer* renderer, SDL_Rect* paddle) {
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);  // 흰색
 SDL_RenderFillRect(렌더, 패들);
}

보이드 드로우볼(SDL_렌더*렌더, SDL_Rect*볼) {
 SDL_SetRenderDrawColor(렌더, 255, 105, 180, 255); // 핑크색
 SDL_RenderFillRect(렌더, 볼);
}

void drawBlocks(SDL_Renderer* Renderer, 블록 블록[B]LOCK_ROWS[BLOCK_COLUMNS]) {
 (inti = 0; i < BLOCK_ROWS; i++) {
 (int j = 0; j < BLOCK_COLUMns; j++) {
 if (블록[i]][j]인 경우살아있는) {
 SDL_SetRenderDrawColor(렌더, 블록[i][j])color.r, blocks[i][j].색.g. 블록[i][j]색상.b, 255);
 SDL_RenderFillRect(렌더, &blocks[i][j.rect]);
 }
 }
 }
}

// 충돌 감지 및 처리

보이드 체크 충돌(SDL_Rect* 볼, SDL_Rect* 패들, 블록 블록[B]LOCK_ROWS[BLOCK_COLUMNS], int*ballVelX, int*ballVelY) {
 (SDL_Has Intersection(볼, 패들)인 경우) {
 *ballVelY = -*ballVelY;
 }

 (inti = 0; i < BLOCK_ROWS; i++) {
 (int j = 0; j < BLOCK_COLUMns; j++) {
 if (블록[i]][j]인 경우alive & & SDL_Has 교차로(볼, &blocks[i][j.rect]) {
 블록[i][j]alive = false;
 if (ball->y <= blocks[i][j.rect.y || ball->y >= blocks[i][j.rect.y + BLOCK_HIGHT] {
 *ballVelY = -*ballVelY;
 }
 그 외 {
 *ballVelX = -*ballVelX;
 }
 }
 }
 }
}

// 게임 엔드 처리

void renderEndScreen(SDL_Renderer* Renderer, constchar* 메시지, TTF_Font* 글꼴, SDL_Color 색상) {
 SDL_Rect 메시지Rect = { WINDOW_WIDTH / 2 - 150, WINDOW_HEIGHT / 2 - 30, 300, 60};
 renderText2(렌더, 메시지, 글꼴, 색상, 메시지Rect);
}

// 라이프바 그리기 함수 추가

void drawLives (SDL_Renderer* Renderer, intives) {
 SDL_Rect lifeBar = { 20, 20, 20, 20}; // 기본 크기
 SDL_Color lifeColor = {255, 0, 0, 255}; // 빨간색

 (inti = 0; i < lives; ++i) {
 SDL_SetRenderDrawColor(렌더, lifeColor.r, lifeColor.g, lifeColor.b, lifeColor.a);
 SDL_RenderFillRect(렌더, &lifeBar);
 lifeBar.x += 20; // 라이프 바 간격
 }
}

#include "오닉스"h"

int game1 (SDL_Windows*창, SDL_렌더*렌더) {

 /*

 SDL_Windows* 창 = NULL;
 SDL_Renderer* Renderer = NULL;

 (!initSDL(&window, &renderer) {
 printf("초기화 실패!\n");
 반환 -1;
 }

 */

 TTF_Font* 글꼴 = TTF_OpenFont("arial.ttf", 60); // 경로 및 크기 조정
 만약 (! font) {
 printf("폰트를 로드하지 못했습니다! TTF_Error: %s\n", TTF_GetError();
 반환 -1;
 }

 SDL_Rect 패들 = {WIND_WIDTH / 2 - PADE_WIDTH / 2, WIND_HIGHT - 50, PADE_WIDTH, PADE_HIGHT };
 SDL_Rect ball = {WINDOW_WIDTH / 2 - BALL_SIZE / 2, WINDOW_HIGHT / 2, BALL_SIZE };
 intballVelX = 200;
 intball VelY = 200;

 블록블록[B]LOCK_ROWS][BLOCK_COLUMNS];
 (inti = 0; i < BLOCK_ROWS; i++) {
 (int j = 0; j < BLOCK_COLUMns; j++) {
 블록[i][j]rect = (SDL_Rect){ j * (BLOCK_WIDTH + 6) + 47, i * (BLOCK_HEIGHT + 6) + 47, BLOCK_WIDTH, BLOCK_HEIGHT };
 블록[i][j]color = (SDL_Color){ 0, 0, 255, 255}; // Blue color
 블록[i][j]alive = true;
 }
 }

 bool tit = false;
 SDL_이벤트;
 int lives = 5;
 Bool gameOver = false;
 불 게임원 = 거짓;
 Uint32 마지막 시간 = SDL_GetTicks();

 그만두는 동안에
 반면 (SDL_PollEvent(&e)!= 0) {
 (예: type == SDL_QUIT) {
 = true를 종료합니다.
 }
 }

 if (gameOver || gameWon) {
 (예: type == SDL_KEYDOWN) {
 만약에(e.key)키시미sym == SDLK_RETURN || e.key.키시미sym == SDLK_SPACE) {
 = true를 종료합니다.
 }
 }
 계속합니다.
 }

 // 마우스에 따라 패들 이동
 마우스 X에서;
 SDL_GetMouseState(&mouseX, NULL);
 paddle.x = 마우스 X - PADLE_WIDTH / 2;

 Uint32 current Time = SDL_GetTicks();
 float deltaTime = (현재 시간 - 마지막 시간) / 1000.0f;
 마지막 시간 = 현재 시간;

 }
 ball.y += ballVelY * deltaTime;

 (ball.x <= 0 | ball.x + BALL_SIZE >= WINDOW_WIDTH) {
 ballVelX = -ballVelX;
 }
 만약 (ball.y <= 0) {
 ballVelY = -ballVelY;
 }

 (ball.y + BALL_SIZE >= WINDOW_HEIGHT) {
 생명은--;
 (lives <= 0) {
 GameOver = true;
 }
 그 외 {
 ball.x = WINDOW_WIDTH / 2 - BALL_SIZE / 2;
 ball.y = WINDOW_HIGHT / 2;
 ballVelX = 200;
 ballVelY = 200;
 }
 }

 충돌 점검(&ball, &paddle, 블록, &ballVelX, &ballVelY);

 gameWon = true;
 (inti = 0; i < BLOCK_ROWS; i++) {
 (int j = 0; j < BLOCK_COLUMns; j++) {
 if (블록[i]][j]인 경우살아있는) {
 GameWon = false;
 }
 }
 }

 SDL_Set RenderDraw Color(렌더, 0, 0, 0, 255);
 SDL_RenderClear(렌더);

 생명을 그리다(렌더, 생명);
 드로패들(렌더, &패들);
 드로우볼(렌더, &볼);
 블록 그리기(렌더, 블록);
        

 SDL_Color Red Color = {255, 0, 0, 255}; // Red color
 SDL_Color WhiteColor = { 255, 255, 255, 255}; // WhiteColor
 만약 (게임 오버) {
 렌더 엔드 스크린(렌더, "게임 오버", 글꼴, 빨간색)
 }
 그렇지 않으면 (게임원) {
 렌더 엔드 스크린(렌더, "게임 클리어", 글꼴, 흰색);
 }

 SDL_RenderPresent(렌더);
 }

 /*
 TTF_CloseFont(font);
 닫기 SDL(윈도우, 렌더러);
 */

 반환 0;
}

소감: ai가 프로그래머를 대체할 날은 아직 한참 멀었다는 것을 몸으로 느꼈습니다.
